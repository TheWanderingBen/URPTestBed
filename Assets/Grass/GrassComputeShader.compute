// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

struct SourceVertex
{
    float3 positionOS;
    float2 uv;
};

struct GeneratedVertex
{
    float3 positionOS;
    float3 normalOS;
    float2 uv;
};

StructuredBuffer<SourceVertex> _SourceGrassBladeVertices;
StructuredBuffer<int> _SourceGrassBladeIndices;
RWStructuredBuffer<GeneratedVertex> _GeneratedVertices;
RWStructuredBuffer<int> _GeneratedIndices;
int _NumBlades;
int _NumGrassBladeVertices;
int _NumGrassBladeIndices;
float2 _MinMaxRandomScale;
float2 _Extents;
float _Density;
float _MaxRandomPositionShift;

float RandomNumber(float seed)
{    
    return frac(sin(dot(float2(seed, seed), float2(12.9898,78.233))) * 43758.5453123);
}

float3 RandomScale(float3 inputPosition, float randomNumber)
{
    const float remappedRandom = _MinMaxRandomScale.x + randomNumber * (_MinMaxRandomScale.y - _MinMaxRandomScale.x);
    return inputPosition * remappedRandom;
}

float3 RandomRotation(float3 inputPosition, float randomNumber)
{
    const float randomRotation = randomNumber * 3.14159265 * 2.0;
    const float3x3 randomRotationMatrix = { cos(randomRotation), 0, sin(randomRotation), 0, 1, 0, -sin(randomRotation), 0, cos(randomRotation) };
    return mul(randomRotationMatrix, inputPosition);    
}

float3 CalculateTriangleNormal(float3 a, float3 b, float3 c)
{
    return normalize(cross(b-a, c-a));
}

GeneratedVertex MakeGeneratedVertex(SourceVertex inputVertex)
{
    GeneratedVertex outputVertex;
    outputVertex.positionOS = inputVertex.positionOS;
    outputVertex.normalOS = float3(0,1,0);
    outputVertex.uv = inputVertex.uv;
    return outputVertex;
}

[numthreads(128,1,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= _NumBlades)
        return;

    const float randomNumber = RandomNumber(id.x);
    
    float xCoord = (id.x * _Density) % _Extents.x + _MaxRandomPositionShift * randomNumber - _Extents.x / 2.0;
    float zCoord = floor(id.x * _Density / _Extents.x) * _Density + _MaxRandomPositionShift * randomNumber - _Extents.y / 2.0;
    const float3 groundVertexPosition = float3(xCoord, 0, zCoord);
    
    const int grassVertexStart = id.x * _NumGrassBladeVertices;
    for (int i = 0; i < _NumGrassBladeVertices; ++i)
    {
        SourceVertex grassBladeVertex;
        grassBladeVertex.positionOS = groundVertexPosition + RandomRotation(RandomScale(_SourceGrassBladeVertices[i].positionOS, randomNumber), randomNumber);
        grassBladeVertex.uv = _SourceGrassBladeVertices[i].uv;
        _GeneratedVertices[grassVertexStart + i] = MakeGeneratedVertex(grassBladeVertex);
    }

    const int grassIndexStart = id.x * _NumGrassBladeIndices;
    for (int i = 0; i < _NumGrassBladeIndices; ++i)
    {        
        _GeneratedIndices[grassIndexStart + i] = grassVertexStart + _SourceGrassBladeIndices[i];
    }
}
