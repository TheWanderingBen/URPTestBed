// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

struct SourceVertex
{
    float3 positionOS;
    float2 uv;
};

struct GeneratedVertex
{
    float3 positionOS;
    float3 normalOS;
    float2 uv;
};

StructuredBuffer<SourceVertex> _SourceGroundVertices;
StructuredBuffer<int> _SourceGroundIndices;
StructuredBuffer<SourceVertex> _SourceGrassBladeVertices;
StructuredBuffer<int> _SourceGrassBladeIndices;
RWStructuredBuffer<GeneratedVertex> _GeneratedVertices;
RWStructuredBuffer<int> _GeneratedIndices;
int _NumGroundVertices;
int _NumGrassBladeVertices;
int _NumGrassBladeIndices;
float4x4 _Transform;

float3 RandomRotation(float3 inputPosition, int seed)
{
    const float randomNumber = frac(sin(dot(float2(seed, seed), float2(12.9898,78.233))) * 43758.5453123) * 3.14159265 * 2.0;
    const float3x3 randomTransform = { cos(randomNumber), 0, sin(randomNumber), 0, 1, 0, -sin(randomNumber), 0, cos(randomNumber) };
    return mul(randomTransform, inputPosition);    
}

float3 CalculateTriangleNormal(float3 a, float3 b, float3 c)
{
    return normalize(cross(b-a, c-a));
}

GeneratedVertex MakeGeneratedVertex(SourceVertex inputVertex)
{
    GeneratedVertex outputVertex;
    outputVertex.positionOS = inputVertex.positionOS;
    outputVertex.normalOS = float3(0,1,0);
    outputVertex.uv = inputVertex.uv;
    return outputVertex;
}

[numthreads(128,1,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= _NumGroundVertices)
        return;
    
    const float3 transformedGroundVertexPosition = mul(_Transform, float4(_SourceGroundVertices[id.x].positionOS, 1)).xyz;
    const int grassVertexStart = id.x * _NumGrassBladeVertices;
    for (int i = 0; i < _NumGrassBladeVertices; ++i)
    {
        SourceVertex grassBladeVertex;
        grassBladeVertex.positionOS = transformedGroundVertexPosition + RandomRotation(_SourceGrassBladeVertices[i].positionOS, id.x);
        grassBladeVertex.uv = _SourceGrassBladeVertices[i].uv;
        _GeneratedVertices[grassVertexStart + i] = MakeGeneratedVertex(grassBladeVertex);
    }

    const int grassIndexStart = id.x * _NumGrassBladeIndices;
    for (int i = 0; i < _NumGrassBladeIndices; ++i)
    {        
        _GeneratedIndices[grassIndexStart + i] = grassVertexStart + _SourceGrassBladeIndices[i];
    }
}
